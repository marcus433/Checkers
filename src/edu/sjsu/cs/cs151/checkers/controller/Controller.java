package edu.sjsu.cs.cs151.checkers.controller;

import edu.sjsu.cs.cs151.checkers.model.Checker;
import edu.sjsu.cs.cs151.checkers.model.Model;
import edu.sjsu.cs.cs151.checkers.model.Position;
import edu.sjsu.cs.cs151.checkers.view.Gameboard;
import edu.sjsu.cs.cs151.checkers.view.MainView;
import edu.sjsu.cs.cs151.checkers.view.Piece;
import edu.sjsu.cs.cs151.checkers.view.Tile;

import java.util.List;
import java.awt.Point;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.concurrent.BlockingQueue;

import javax.swing.JPanel;

/**
 * Controller acts an intermediary between View and Model, and alters both when either changes.
 * It operates by receiving Message objects from a BlockingQueue queue, which are generated by View;
 * and then uses these Messages to alter Model accordingly, which in turn may affect View.
 * 
 * It also contains the private Valve interface and several specialized Valve classes
 * that interact with their corresponding specialized Message classes.
 * @author seanz
 *
 */
public class Controller {

   /**
    * Constructor for Controller taken from lecture slides.
    * @param view
    * @param model
    * @param queue
    */
   public Controller(MainView view, Model model, BlockingQueue<Message> queue) {
      this.view = view;
      this.model = model;
      this.messageQueue = queue;
      
      valves.add(new SelectMessageValve());
      valves.add(new ResetMessageValve());
      valves.add(new SkipTurnMessageValve());
   }
   
   /**
    * mainLoop indefinitely monitors queue, accepts Messages from it, and acts accordingly.
    * Method body taken from lecture slides.
    */
   public void mainLoop() {
// 	view.updateState(model);
      updateState();
      Valve.ValveResponse response = Valve.ValveResponse.EXECUTED;
      Message message = null;
      
      while (response != Valve.ValveResponse.FINISH) {
         try {
            message = (Message) messageQueue.take();
         }
         catch (InterruptedException e) {
            e.printStackTrace();
         }
         for (Valve valve : valves) {
             response = valve.execute(message);
             if (response != Valve.ValveResponse.MISS)
                break;
          }
      }
   }
   
   // Private fields
   
   private BlockingQueue<Message> messageQueue;
   private MainView view;
   private Model model;
   private List<Valve> valves = new LinkedList<Valve>();
   
   // Valves
   
   /**
    * The Valve interface allows Valve subclasses to accept Messages and act accordingly.
    * It contains the method execute(), which takes a Message object and returns a ValveResponse.
    * Valve defines ValveResponse as enums, which represent different Valve outcomes, as follows:
    * MISS is returned when a Valve object is passed a mismatched Message,
    * EXECUTED is returned when a Valve object is passed a correct Message and is able to act accordingly, and
    * FINISH is returned when a player quits or closes the game.
    * @author seanz
    *
    */
   private interface Valve {
      enum ValveResponse {
         MISS, EXECUTED, FINISH;
      }
      
      /**
       * execute() takes a Message as an argument and returns the appropriate ValveResponse.
       * @param message - a Message generated by MainView
       * @return - a ValveResponse of either MISS, EXECUTED, or FINISH.
       *    Returns MISS on a mismatched Message, EXECUTED on a successfully processed Message,
       *    and FINISH when the player quits/closes the game.
       */
      public ValveResponse execute(Message message);
   }
   
   /**
    * SelectMessageValve processes SelectMessage objects, which represent user mouse click input.
    * @author seanz
    *
    */
   private class SelectMessageValve implements Valve {
      
      /**
       * SelectMessageValve's execute() determines whether a user's selected location can be interacted with.
       * From the coordinates contained in the message, it first determines whether the user has already
       * selected a piece. If there isn't one, it checks if it can select one; if the user has selected one,
       * then it determines if the selected location can be moved to.
       * @param message - takes all Message objects, but only fully executes when passed SelectMessage objects
       * @return - Valve.ValveResponse.MISS if message isn't a SelectMessage; Valve.ValveResponse.EXECUTED otherwise
       */
      public ValveResponse execute(Message message) {
         if (message.getClass() != SelectMessage.class)
            return Valve.ValveResponse.MISS;
         
         SelectMessage selectMsg = (SelectMessage) message;
         Position atClick = new Position(selectMsg.getRow(), selectMsg.getColumn());
         
         // actions in Model
         // selecting a piece
         if (model.getBoard()[selectMsg.getRow()][selectMsg.getColumn()].hasPiece()) {
            if (!model.selectChecker(atClick))
               return Valve.ValveResponse.EXECUTED;
         }
         // moving a piece
         else { // if (model.getCurrentPiece != null)
            if (!model.movePiece(atClick))
               return Valve.ValveResponse.EXECUTED;
         }
         
         //Position[] validMoves = model.determineValidMoves();
         
         // actions in View
         // TODO: highlight valid move destinations
         
         //view.updateState(model);
         updateState();
         
         return Valve.ValveResponse.EXECUTED;
      }
   }
   
   /**
    * ResetMessageValve processes ResetMessage objects, which are generated when a player clicks the Reset button.
    * @author seanz
    *
    */
   private class ResetMessageValve implements Valve {
      
      /**
       * ResetMessageValve's execute(), upon receiving a ResetMessage, will return all Pieces on the board to their initial positions.
       * @param message - takes all Message objects, but only executes the method body upon a ResetMessage
       * @return - Valve.ValveResponse.MISS if message isn't a ResetMessage; Valve.ValveResponse.EXECUTED otherwise
       */
      public ValveResponse execute(Message message) {
         if (message.getClass() != ResetMessage.class)
            return Valve.ValveResponse.MISS;
         
         // actions in Model
         model.reset();
         
         // actions in View
         // TODO: reset the game board
         
         //view.updateState(model);
         updateState();
         
         return Valve.ValveResponse.EXECUTED;
      }
   }
   
   /**
    * SkipTurnMessageValve processes SkipTurnMessages, which indicate that the user has pressed the Skip Turn button.
    * @author seanz
    *
    */
   private class SkipTurnMessageValve implements Valve {
      
      /**
       * SkipTurnMessageValve's execute(), upon receiving a SkipTurnMessage, switches Model's active color.
       * @param message - any Message object, but only executes method body on a SkipTurnMessage
       * @return - Valve.ValveResponse.MISS if message isn't a SkipTurnMessage; Valve.ValveResponse.EXECUTED otherwise
       */
      public ValveResponse execute(Message message) {
         if (message.getClass() != SkipTurnMessage.class)
            return Valve.ValveResponse.MISS;
         
         // actions in Model
         model.switchTurn();
         
         // actions in View
         
         //view.updateState(model);
         updateState();
         
         return Valve.ValveResponse.EXECUTED;
      }
   }
   
   /**
    * updateState() updates the MainView object and therefore the GUI.
    * It calls updateGameboardState() and updateToolbarState(), which themselves update their respective components.
    */
   private void updateState() {
      updateGameboardState();
      updateToolbarState();
   }
   
   /**
    * updateToolbarState() updates the state of the Toolbar component in MainView.
    * This amounts to monitoring the current player's turn, and reflecting it in the color piece shown on the toolbar.
    */
   private void updateToolbarState() {
      edu.sjsu.cs.cs151.checkers.model.Piece.Color color = model.getCurrentColor();
      edu.sjsu.cs.cs151.checkers.view.CurrentTurn currentTurn = view.getToolbar().getCurrentTurn();
      if (color == edu.sjsu.cs.cs151.checkers.model.Piece.Color.RED)
         currentTurn.setColor(Piece.Color.RED);
      else
         currentTurn.setColor(Piece.Color.BLACK);
   }
   
   /**
    * updateGameboardState() updates the state of the Gameboard component in MainView, which contains the locations of all Pieces.
    * It also manages the animations of pieces if they were moved from one turn to the next.
    */
   private void updateGameboardState() {
      Point changeOrigin = new Point(0, 0);
      Point changeDestination = new Point(0, 0);
      Boolean isChange = false;
      edu.sjsu.cs.cs151.checkers.view.Piece view = null;
      Tile originTile = null;
      Checker[][] checkers = model.getBoard();
      ArrayList<Tile> tiles = this.view.getGameboard().getTiles();
      
      Position origin = model.getLastOrigin();
      Position dest = model.getOrigin();

      if (origin != null && dest != null && !origin.equals(dest)) {
         int row = origin.getRow();
         int column = origin.getColumn();
         Checker checker = checkers[row][column];
         edu.sjsu.cs.cs151.checkers.model.Piece piece = checker.getPiece();
         Tile tile = (Tile) tiles.get((8 * row) + column);
         edu.sjsu.cs.cs151.checkers.view.Piece pieceView = tile.getPiece();
         changeOrigin = tile.getLocation();
         changeOrigin = new Point((int)changeOrigin.getX() + 5, (int)changeOrigin.getY() + 5);
         view = pieceView;
         isChange = true;
         originTile = tile;
         row = dest.getRow();
         column = dest.getColumn();
         tile = (Tile) tiles.get((8 * row) + column);
         changeDestination = tile.getLocation();
         changeDestination = new Point((int)changeDestination.getX() + 5, (int)changeDestination.getY() + 5);
      } else {
         for (int row = 0; row < checkers.length; row++) {
            for (int column = 0; column < checkers[row].length; column++) {
               Checker checker = checkers[row][column];
               edu.sjsu.cs.cs151.checkers.model.Piece piece = checker.getPiece();
               Tile tile = (Tile) tiles.get((8 * row) + column);
               edu.sjsu.cs.cs151.checkers.view.Piece pieceView = tile.getPiece();
               if (pieceView != null && !pieceView.isVisible() && checker.hasPiece()) {
                  changeDestination = tile.getLocation();
                  changeDestination = new Point((int)changeDestination.getX() + 5, (int)changeDestination.getY() + 5);
                  isChange = true;
               } else if (pieceView != null && pieceView.isVisible() && !checker.hasPiece()) {
                  changeOrigin = tile.getLocation();
                  changeOrigin = new Point((int)changeOrigin.getX() + 5, (int)changeOrigin.getY() + 5);
                  view = pieceView;
                  isChange = true;
                  originTile = tile;
               }
            }
         }
      }

      if (isChange && originTile != null && view != null) {
         view.setVisible(false);
         final edu.sjsu.cs.cs151.checkers.view.Piece tempView = view.copy();
         tempView.setVisible(true);
         tempView.setLocation(changeOrigin);
         tempView.setSize(view.getSize());
         this.view.getGameboard().add(tempView, 0);
         final JPanel _view = view;
         final Gameboard that = this.view.getGameboard();
         new AnimationController(tempView)
            .animateTo(500, changeDestination)
            .onComplete(new AnimationController.Callback(){
                  @Override
                  public void onSuccess() {
                     that.remove(tempView);
                     for (int row = 0; row < checkers.length; row++) {
                        for (int column = 0; column < checkers[row].length; column++) {
                           Checker checker = checkers[row][column];
                           edu.sjsu.cs.cs151.checkers.model.Piece piece = checker.getPiece();
                           Tile tile = (Tile) tiles.get((8 * row) + column);
                           edu.sjsu.cs.cs151.checkers.view.Piece pieceView = tile.getPiece();
                           if (piece != null && pieceView != null) {
                              pieceView.setType(piece.isKing() ? edu.sjsu.cs.cs151.checkers.view.Piece.Type.KING : edu.sjsu.cs.cs151.checkers.view.Piece.Type.PAWN);
                              pieceView.setColor(piece.getColor() == edu.sjsu.cs.cs151.checkers.model.Piece.Color.RED ? edu.sjsu.cs.cs151.checkers.view.Piece.Color.RED : edu.sjsu.cs.cs151.checkers.view.Piece.Color.BLACK);
                              pieceView.setVisible(true);
                              if (checker.isSelected()) {
                                 pieceView.select();
                              } else {
                                 pieceView.deselect();
                              }
                           } else if (pieceView != null) {
                              pieceView.setVisible(false);
                           }
                        }
                     }
                     that.repaint();
                  }

                  @Override
                  public void onError(String err) {
                        _view.setVisible(true);
                        that.remove(tempView);
                      System.out.println(err);
                  }
              });
      } else {
         for (int row = 0; row < checkers.length; row++) {
            for (int column = 0; column < checkers[row].length; column++) {
               Checker checker = checkers[row][column];
               edu.sjsu.cs.cs151.checkers.model.Piece piece = checker.getPiece();
               Tile tile = (Tile) tiles.get((8 * row) + column);
               edu.sjsu.cs.cs151.checkers.view.Piece pieceView = tile.getPiece();
               if (piece != null && pieceView != null) {
                  pieceView.setType(piece.isKing() ? edu.sjsu.cs.cs151.checkers.view.Piece.Type.KING : edu.sjsu.cs.cs151.checkers.view.Piece.Type.PAWN);
                  pieceView.setColor(piece.getColor() == edu.sjsu.cs.cs151.checkers.model.Piece.Color.RED ? edu.sjsu.cs.cs151.checkers.view.Piece.Color.RED : edu.sjsu.cs.cs151.checkers.view.Piece.Color.BLACK);
                  pieceView.setVisible(true);
                  if (checker.isSelected()) {
                     pieceView.select();
                  } else {
                     pieceView.deselect();
                  }
               } else if (pieceView != null) {
                  pieceView.setVisible(false);
               }
            }
         }
      }
      this.view.getGameboard().repaint();
   }
}


